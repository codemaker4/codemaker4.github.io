<!doctype HTML>
<html>
  <head>
    <meta charset="utf-8">
    <title>CM4 home</title>
    <link rel="stylesheet" href="style/style.css">
    <link rel="icon" href="images/CM4 logo.png">
  </head>
  <body>
    <div id="mainHeaderContainer">
      <header id="mainHeader">
        <img src="images/CM4 logo.png" id="mainHeader" alt="">
        <h1 class="center" id="mainHeader">CodeMaker_4</h1>
      </header>
    </div>
    <nav id="mainNav">
      <div id="mainLinkContainer">
        <a class="navLink" href="index.html">Home</a>
        <a class="navLink" href="projects.html">Projects</a>
        <a class="navLink" href="https://www.youtube.com/c/CodeMaker4" target="_blank">YouTube</a>
        <a class="navLink" href="https://discord.gg/zNjSsBk" target="_blank">Discord</a>
      </div>
    </nav>
    <div id="mainBody">
      <div class="postLayer">
        <div class="postContainer">
          <div class="postTextHalf">
            <h2 class="mainBodyTitle">2d math plotter</h2>
            <a href="https://codemaker4.github.io/codemakers_plotter/" target="_blank">https://codemaker4.github.io/codemakers_plotter</a>
            <p>
              Codemaker's Plotter is my JavaScript real-time math plotting project.<br>
              The latest version, which is the fifth rewrite, uses multithreadding to utilise the full computing capacity of a users CPU. I also added a simple gui, and no longer use <code>prompt()</code> and <code>alert()</code>.<br>
              
              In the function input, you can give any JavaScript function. This function is executed for every pixel on the screen. It has an x and y input, and can output colors in various ways using booleans or numbers between 0 and 1.<br>
              The idea is that this function would, based on it's position, create different colors. When many of these pixels are calculated next to eachother, mathematical patterns can emerge.<br>
              By default, it shows the mandelbrot set at 1k iterations. You can adjust the iteration limit with the <code>maxI</code> variable.
              <br>
              The x and y inputs are the coordinates of the center of the view. The scale is how zoomed out the view is. So values &gt; 1 zoom out, and values &lt; 1 zoom in.<br>
              <br>
              You can also see more options by pressing the advanced button.<br>
              Tasks are the amount of chunks that are being calculated, or are waiting to get a <span title="In JS, they are actually called workers">thread</span> assigned.<br>
              Pix size is the current quality that is being worked on. If it is &gt; 1, the pixels being calculated are larger than the pixels of your monitor, and if it is &lt; 1, then multiple samples are being calculated per pixel for an anti-alias effect.<br>
              What pixel sizes are being used, is determined by the Level Of Detail parameters. Basically, to calculate a pixel size, you do <code>LOD_power ^ current_LOD_number</code>, where LOD_power is a constant determining how much the quality changes per level, and the current_LOD_number is a integer that starts at the lod start input, and decreases by 1 every time the full image has been calculated at the current pixSize. To prevent your CPU from trying to calculate an infinitely fine LOD, there is also a lod end input that is the lowest value the current_LOD_power will reach.<br>
              Also, the more negative the LOD end is, the higher the quality and the higher the computational load. So if you want to get finer details, set LOD end to a lower (possibly negative) integer, like -2, and if you want the first pass of the rendering to be at an even lower resolution, set the LOD start to a higher value. Finally, if you want to increase the step size, increase the lod power to a higher integer.<br>
              <br>
              Then there is the pixels per chunk input. It sets the maximum amount of pixels that can be in a single task. The lower this value, the more individual chunks there are, the more the seperate tasks will be flowing through the threads and the more control the queue system has over what thread does what calculations. But setting this to a too low value means that the computational cost of creating and managing too many individual tasks can outweigh the benefits. 10k pixels per tasks is a good value for me. In general, I advise making sure that the queue length does not exceed 50 tasks per thread.<br>
              And lastly, there is the thread count. This determines how many workers are created. I advise setting this to the amount of threads your CPU can handle. (For win10 users, go to task manager -&gt; performance -&gt; CPU and look at the logical processors stat.) Creating more threads than your CPU can handle won't break the plotter, but will not increase performance either. Decreasing the thread count will cap the amount of CPU the plotter can use, which effectively is a battery saver mode.
            </p>
          </div>
          <div class="postImageHalf">
            <img src="images/jsmath/MandelbrotZoomSize.png" alt="">
          </div>
        </div>
      </div>
      <div class="postLayer">
        <div class="postContainer">
          <div class="postTextHalf">
            <h2 class="mainBodyTitle">Terrain generator</h2>
            <a href="https://codemaker4.github.io/jsWorldGen/" target="_blank">codemaker4.github.io/jsWorldGen</a>
            <p>I made a simple terrain generating program that also visualises the terrain. Blue colors are low terain or water, green is land at slightly above sea level, and red/brown land represents high mountains.<br>
            You can move around by using WASD or by dragging with your mouse. This does also work on your phone, but it is kinda slow.<br>
            It generates this terrain by first making a lot of points with a random position and height. Then, for each pixel, the program determines the height of the land on that pixel as a weighted average of the nearby points.<br>
            But this is a slow algorithim, so to keep a decent framerate while moving around, the terrain is generated in chunks, beginning at a low resolution, and if the CPU has some time to spare, it will try to increase the resolution of existing chunks if they are on screen.</p>
          </div>
          <div class="postImageHalf">
            <img src="images/jsworldgen/Screenshot.png" alt="">
          </div>
        </div>
      </div>
      <div class="postLayer">
        <div class="postContainer">
          <div class="postTextHalf">
            <h2 class="mainBodyTitle">Simple runner game</h2>
            <a href="https://codemaker4.github.io/JSrunner/" target="_blank">codemaker4.github.io/JSrunner</a>
            <p>So the first project that is worthy of being shown here is this runner game I made called JSrunner because it's a runner made in JavaScript and I could not think of a better name. The graphics are simplistic at best, and my English spelling skills were terrible back then, but it is still a nice piece of code.<br>
            The main objective is to jump over obstacles and not hit them for as long as possible. You can jump with the spacebar or the upwards arrow on your keyboard, and simply clicking will also jump to make this game work on mobile devices.<br>
            I also made a feature where you can customise the look of the obstacles. Just press 'o', paste a link to an online image and press ok. For some reason, the prompt doesn't dissapear properly because of some changes to how events work in p5.js, the library/game engine I used, but it also saves that link to localstorage, so just refresh the page and jump over cactusses instead of grey blocks.</p>
          </div>
          <div class="postImageHalf">
            <img src="images/jsrunner/screenshot1.png" alt="">
            <img src="images/jsrunner/death.png" alt="">
          </div>
        </div>
      </div>
    </div>
  </body>
</html>